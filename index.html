<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Perfume World Viewer</title>
        <style>canvas { width: 100%; height: 100% }</style>
    </head>
    <body>
        <div id="container"></div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r68/three.min.js"></script>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
        <script src="js/controls/TrackballControls.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/libs/stats.min.js"></script>
        <script type="text/javascript">
            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            var area, section, number;
            var cubes = [];
            var container, stats;
            var camera, controls, scene, renderer;
            var cube, plane;
            var cross;

            $(window).on('hashchange',function(){ 
                loadHash();
            });

            loadHash();
            init();
            animate();

            function loadHash() {
                var m = window.location.hash.match(/#(\d+)-(\d+)-(\d+)/)
                if (m != null && m.length == 4) {
                    area = m[1];
                    section = m[2];
                    number = m[3];
                    var addr = area + "-" + section + "-" + number;
                    $.ajax({
                        dataType: "json",
                        url: "maps/" + area + ".json", 
                        success: function(data) {
                            var addresses = data["addresses"];

                            for (var i = 0; i < addresses.length; i++) {
                                if (addresses[i]["address"] === addr) {
                                    var voxels = JSON.parse(addresses[i]["voxel"])["voxels"];
                                    loadModel(scene, voxels);
                                    render();
                                    break;
                                }
                            }
                        }
                    })
                }
            }

            function loadModel(scene, voxels) {
                for (var i = 0; i < cubes.length; i++) {
                    scene.remove(cubes[i]);
                }
                cubes = [];

                // 80 x 55
                for (var v = 0; v < voxels.length; v++) {
                    var voxel = voxels[v];
                    var geometry = new THREE.BoxGeometry( voxel["w"] * 10, voxel["h"] * 10, voxel["d"] * 10 );
                    for ( var i = 0; i < geometry.faces.length; i += 2 ) {
                        geometry.faces[ i ].color.setHex( voxel["color"] );
                        geometry.faces[ i + 1 ].color.setHex( voxel["color"] );
                    }
                    var material = new THREE.MeshPhongMaterial( { color: new THREE.Color(voxel["color"]), shininess: 30, shading: THREE.SmoothShading } );
                    cube = new THREE.Mesh( geometry, material );
                    cube.position.x = voxel["x"] * 10 + voxel["w"] * 5 - 80 * 5;
                    cube.position.y = voxel["y"] * 10 + voxel["h"] * 5;
                    cube.position.z = - (voxel["z"] * 10 + voxel["d"] * 5) + 55 * 5;
                    scene.add( cube );
                    cubes.push(cube);
                }
                
            }

            function init() {

                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
                camera.position.z = 600;
                camera.position.y = 400;

                controls = new THREE.TrackballControls( camera );

                controls.rotateSpeed = 2.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;

                controls.noZoom = false;
                controls.noPan = false;

                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;

                controls.keys = [ 65, 83, 68 ];

                controls.addEventListener( 'change', render );

                // world

                scene = new THREE.Scene();
                // scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
                // Plane

                // var geometry = new THREE.PlaneGeometry( 200, 200 );
                // geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

                // var material = new THREE.MeshBasicMaterial( { color: 0xe0e0e0, overdraw: 0.5 } );

                // plane = new THREE.Mesh( geometry, material );
                // scene.add( plane );
                
                light = new THREE.PointLight( 0xffffff, 1.0, 1200 );
                light.position.set( 50, 800, -20 );
                scene.add( light );

                light = new THREE.PointLight( 0xffffff, 1.0, 1200 );
                light.position.set( -800, 0, -300 );
                scene.add( light );

                light = new THREE.PointLight( 0xffffff, 1.0, 1200 );
                light.position.set( 120, -10, 450 );
                scene.add( light );

                light = new THREE.PointLight( 0xffffff, 1.0, 1200 );
                light.position.set( 600, 0, -300 );
                scene.add( light );

                light = new THREE.HemisphereLight(0xffffff, 0x333333, 0.5);
                scene.add(light);


                // renderer

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                // renderer.setClearColor( scene.fog.color, 1 );
                renderer.setSize( window.innerWidth, window.innerHeight );

                container = document.getElementById( 'container' );
                container.appendChild( renderer.domElement );

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.zIndex = 100;
                container.appendChild( stats.domElement );

                //

                window.addEventListener( 'resize', onWindowResize, false );

                //

                render();

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

                controls.handleResize();

                render();

            }

            function animate() {
                requestAnimationFrame( animate );
                controls.update();
            }

            function render() {
                renderer.render( scene, camera );
                stats.update();
            }
            //
        </script>
    </body>
</html>